"""
Utility functions for validating and editing LLM-generated labels for IATI activities.

This module provides interactive tools to review, validate, and correct
the labels generated by the DSPy classifier.
"""

import json
import os
from typing import Dict, List, Any
from lib.util_file import read_json, write_json
from definitions import DATASTORE_FIELDS


class LabelValidator:
    """Interactive validator for LLM-generated labels."""
    
    def __init__(self):
        self.valid_ref_groups = ["Syria", "Palestine", "Iraq", "Yemen", "Sudan", "Other", "mixed_or_unspecified_refugees"]
        self.valid_target_populations = ["refugees", "host_communities", "general_population"]
        self.valid_settings = ["camp", "urban", "rural"]
        self.valid_nexus = ["humanitarian", "development"]
        
        self.label_fields = [
            'llm_ref_group',
            'llm_target_population', 
            'llm_ref_setting',
            'llm_geographic_focus',
            'llm_nexus',
            'llm_funding_org',
            'llm_implementing_org'
        ]
    
    def validate_field(self, field_name: str, value: List) -> bool:
        """Validate a specific field against allowed values."""
        if field_name == 'llm_ref_group':
            return all(v in self.valid_ref_groups for v in value)
        elif field_name == 'llm_target_population':
            return all(v in self.valid_target_populations for v in value)
        elif field_name == 'llm_ref_setting':
            return all(v in self.valid_settings for v in value)
        elif field_name == 'llm_nexus':
            return all(v in self.valid_nexus for v in value)
        elif field_name in ['llm_geographic_focus', 'llm_funding_org', 'llm_implementing_org']:
            return isinstance(value, list)  # Just check it's a list
        return True
    
    def display_activity(self, activity: Dict, index: int, total: int):
        """Display activity information in a readable format."""
        print("\n" + "="*80)
        print(f"ACTIVITY {index + 1} of {total}")
        print("="*80)
        
        print(f"\nüìã TITLE:")
        title = activity.get('title_narrative', ['N/A'])
        if isinstance(title, list):
            title = title[0] if title else 'N/A'
        print(f"   {title}")
        
        print(f"\nüìù DESCRIPTION:")
        desc = activity.get('description_narrative', ['N/A'])
        if isinstance(desc, list):
            desc = desc[0] if desc else 'N/A'
        if isinstance(desc, str) and len(desc) > 300:
            print(f"   {desc[:300]}...")
        else:
            print(f"   {desc}")
        
        print(f"\nüè∑Ô∏è  SECTOR:")
        sector = activity.get('sector_narrative', ['N/A'])
        if isinstance(sector, list):
            sector = sector[0] if sector else 'N/A'
        print(f"   {sector}")
        
        # Add other narrative elements
        print(f"\nüìÑ OTHER NARRATIVE ELEMENTS:")
        narrative_fields = [field for field in DATASTORE_FIELDS if "narrative" in field and "xml_lang" not in field]
        # Remove title, description, and sector as we already display them above
        narrative_fields = [field for field in narrative_fields if field not in ['title_narrative', 'description_narrative', 'sector_narrative']]
        
        has_content = False
        for field_name in narrative_fields:
            value = activity.get(field_name, '')
            if value and value.strip():
                if not has_content:
                    has_content = True
                # Create display name from field name
                display_name = field_name.replace('_narrative', '').replace('_', ' ').title()
                # Truncate long values
                if len(value) > 100:
                    value = value[:100] + "..."
                print(f"   ‚Ä¢ {display_name}: {value}")
        
        if not has_content:
            print("   (No additional narrative content)")
        
        print(f"\nü§ñ CURRENT LABELS:")
        for i, field in enumerate(self.label_fields, 1):
            value = activity.get(field, [])
            valid = "‚úÖ" if self.validate_field(field, value) else "‚ùå"
            display_name = field.replace('llm_', '').replace('_', ' ').title()
            value_display = ', '.join(value) if value else '(empty)'
            
            # Get available options for constrained fields
            options_display = ""
            if field == 'llm_ref_group':
                options_display = f"  ‚îÇ Options: {', '.join(self.valid_ref_groups)}"
            elif field == 'llm_target_population':
                options_display = f"  ‚îÇ Options: {', '.join(self.valid_target_populations)}"
            elif field == 'llm_ref_setting':
                options_display = f"  ‚îÇ Options: {', '.join(self.valid_settings)}"
            elif field == 'llm_nexus':
                options_display = f"  ‚îÇ Options: {', '.join(self.valid_nexus)}"
            elif field in ['llm_geographic_focus', 'llm_funding_org', 'llm_implementing_org']:
                options_display = "  ‚îÇ Free text (comma-separated)"
            
            print(f"   {i}. {display_name:20} {value_display} {valid}{options_display}")
    
    def edit_field(self, current_value: List, field_name: str) -> List:
        """Interactive editing of a field value with user-friendly input."""
        print(f"\nüîß Editing {field_name.replace('llm_', '').replace('_', ' ').title()}")
        print(f"üìã Current: {', '.join(current_value) if current_value else '(empty)'}")
        
        # Handle constrained fields with interactive selection
        if field_name in ['llm_ref_group', 'llm_target_population', 'llm_ref_setting', 'llm_nexus']:
            return self._edit_constrained_field(current_value, field_name)
        else:
            return self._edit_free_text_field(current_value, field_name)
    
    def _edit_constrained_field(self, current_value: List, field_name: str) -> List:
        """Edit fields with predefined valid options."""
        valid_options = {
            'llm_ref_group': self.valid_ref_groups,
            'llm_target_population': self.valid_target_populations,
            'llm_ref_setting': self.valid_settings,
            'llm_nexus': self.valid_nexus
        }
        
        options = valid_options[field_name]
        
        print(f"\nüìù Available options:")
        for i, option in enumerate(options, 1):
            selected = "‚úì" if option in current_value else " "
            print(f"   {i:2d}. [{selected}] {option}")
        
        print(f"\nüí° Instructions:")
        print(f"   ‚Ä¢ Enter numbers (e.g., '1 3 5') to select multiple options")
        print(f"   ‚Ä¢ Enter 'clear' to remove all selections")
        print(f"   ‚Ä¢ Press Enter to keep current selection")
        
        user_input = input("üëâ Your choice: ").strip()
        
        if not user_input:
            return current_value
        
        if user_input.lower() == 'clear':
            print("‚úÖ Cleared all selections")
            return []
        
        try:
            # Parse number selections
            selected_indices = [int(x.strip()) - 1 for x in user_input.split()]
            new_value = []
            
            for idx in selected_indices:
                if 0 <= idx < len(options):
                    new_value.append(options[idx])
                else:
                    print(f"‚ö†Ô∏è  Warning: Ignoring invalid option number {idx + 1}")
            
            # Remove duplicates while preserving order
            new_value = list(dict.fromkeys(new_value))
            
            print(f"‚úÖ Updated to: {', '.join(new_value) if new_value else '(empty)'}")
            return new_value
            
        except ValueError:
            print("‚ùå Error: Please enter valid numbers separated by spaces")
            return current_value
    
    def _edit_free_text_field(self, current_value: List, field_name: str) -> List:
        """Edit free-text fields like geographic focus, organizations."""
        print(f"\nüí° Instructions:")
        print(f"   ‚Ä¢ Enter values separated by commas (e.g., 'Jordan, Amman, Zarqa')")
        print(f"   ‚Ä¢ Enter 'clear' to remove all values")
        print(f"   ‚Ä¢ Press Enter to keep current values")
        
        user_input = input("üëâ Enter values: ").strip()
        
        if not user_input:
            return current_value
        
        if user_input.lower() == 'clear':
            print("‚úÖ Cleared all values")
            return []
        
        # Split by comma and clean up
        new_value = [item.strip() for item in user_input.split(',') if item.strip()]
        
        print(f"‚úÖ Updated to: {', '.join(new_value) if new_value else '(empty)'}")
        return new_value
    
    def review_activities(self, input_file: str, output_file: str = None):
        """Main review loop for activities."""
        if not os.path.exists(input_file):
            print(f"‚ùå Error: File {input_file} not found")
            return
        
        activities = read_json(input_file)
        if not activities:
            print("‚ùå Error: No activities found in file")
            return
        
        if output_file is None:
            base_name = os.path.splitext(input_file)[0]
            output_file = f"{base_name}_corrected.json"
        
        print(f"üöÄ Starting review of {len(activities)} activities")
        print(f"üìÅ Will save corrected labels to: {output_file}")
        print("\nüéÆ COMMANDS:")
        print("  Enter/n     = Next activity")
        print("  e           = Edit current activity")
        print("  b           = Go back to previous activity")
        print("  j <number>  = Jump to activity number")
        print("  f <field>   = Quick edit field (e.g., 'f 1' for ref group)")
        print("  s           = Save and continue")
        print("  q           = Save and quit")
        print("  h           = Show this help")
        
        current_index = 0
        
        while current_index < len(activities):
            activity = activities[current_index]
            self.display_activity(activity, current_index, len(activities))
            
            command = input(f"\n[{current_index + 1}/{len(activities)}] Command: ").strip().lower()
            
            if command == '' or command == 'n':
                # Next activity
                current_index += 1
                
            elif command == 'e':
                # Edit current activity
                self.edit_activity(activity)
                
            elif command.startswith('f '):
                # Quick edit single field
                try:
                    field_num = int(command.split()[1]) - 1
                    if 0 <= field_num < len(self.label_fields):
                        field_name = self.label_fields[field_num]
                        current_value = activity.get(field_name, [])
                        new_value = self.edit_field(current_value, field_name)
                        activity[field_name] = new_value
                    else:
                        print(f"‚ùå Invalid field number. Range: 1-{len(self.label_fields)}")
                except (ValueError, IndexError):
                    print("‚ùå Invalid field command. Use: f <number>")
                    
            elif command == 'h':
                # Show help
                print("\nüéÆ COMMANDS:")
                print("  Enter/n     = Next activity")
                print("  e           = Edit current activity")
                print("  b           = Go back to previous activity")
                print("  j <number>  = Jump to activity number")
                print("  f <field>   = Quick edit field (e.g., 'f 1' for ref group)")
                print("  s           = Save and continue")
                print("  q           = Save and quit")
                print("  h           = Show this help")
                
            elif command == 'b':
                # Previous activity
                if current_index > 0:
                    current_index -= 1
                else:
                    print("‚ùå Already at first activity")
                    
            elif command.startswith('j '):
                # Jump to activity
                try:
                    jump_to = int(command.split()[1]) - 1
                    if 0 <= jump_to < len(activities):
                        current_index = jump_to
                    else:
                        print(f"‚ùå Invalid activity number. Range: 1-{len(activities)}")
                except (ValueError, IndexError):
                    print("‚ùå Invalid jump command. Use: j <number>")
                    
            elif command == 's':
                # Save and continue
                write_json(activities, output_file)
                print(f"‚úÖ Saved progress to {output_file}")
                current_index += 1
                
            elif command == 'q':
                # Save and quit
                write_json(activities, output_file)
                print(f"‚úÖ Saved final results to {output_file}")
                break
                
            else:
                print("‚ùå Unknown command")
        
        # Final save
        write_json(activities, output_file)
        print(f"\nüéâ Review complete! Corrected labels saved to {output_file}")
    
    def edit_activity(self, activity: Dict):
        """Edit all fields of an activity."""
        print("\nüîß EDITING MODE")
        
        while True:
            print("\nüìù Current labels:")
            for i, field in enumerate(self.label_fields, 1):
                value = activity.get(field, [])
                valid = "‚úÖ" if self.validate_field(field, value) else "‚ùå"
                display_name = field.replace('llm_', '').replace('_', ' ').title()
                value_display = ', '.join(value) if value else '(empty)'
                
                # Get available options for constrained fields
                options_display = ""
                if field == 'llm_ref_group':
                    options_display = f"  ‚îÇ Options: {', '.join(self.valid_ref_groups)}"
                elif field == 'llm_target_population':
                    options_display = f"  ‚îÇ Options: {', '.join(self.valid_target_populations)}"
                elif field == 'llm_ref_setting':
                    options_display = f"  ‚îÇ Options: {', '.join(self.valid_settings)}"
                elif field == 'llm_nexus':
                    options_display = f"  ‚îÇ Options: {', '.join(self.valid_nexus)}"
                elif field in ['llm_geographic_focus', 'llm_funding_org', 'llm_implementing_org']:
                    options_display = "  ‚îÇ Free text (comma-separated)"
                
                print(f"   {i}. {display_name:20} {value_display} {valid}{options_display}")
            
            print(f"\nüí° Enter field number (1-{len(self.label_fields)}), 'all' to edit all invalid fields, or 'done' to finish:")
            choice = input("üëâ Your choice: ").strip()
            
            if choice.lower() == 'done':
                break
            elif choice.lower() == 'all':
                # Edit all invalid fields
                for field in self.label_fields:
                    value = activity.get(field, [])
                    if not self.validate_field(field, value):
                        print(f"\nüîß Auto-editing invalid field: {field}")
                        new_value = self.edit_field(value, field)
                        activity[field] = new_value
            else:
                try:
                    field_index = int(choice) - 1
                    if 0 <= field_index < len(self.label_fields):
                        field_name = self.label_fields[field_index]
                        current_value = activity.get(field_name, [])
                        new_value = self.edit_field(current_value, field_name)
                        activity[field_name] = new_value
                    else:
                        print(f"‚ùå Invalid field number. Range: 1-{len(self.label_fields)}")
                except ValueError:
                    print("‚ùå Invalid input. Enter a number, 'all', or 'done'")


def validate_labels_file(input_file: str):
    """Quick validation of all labels in a file."""
    validator = LabelValidator()
    activities = read_json(input_file)
    
    print(f"üîç Validating {len(activities)} activities...")
    
    total_errors = 0
    field_errors = {field: 0 for field in validator.label_fields}
    
    for i, activity in enumerate(activities):
        activity_errors = []
        
        for field in validator.label_fields:
            value = activity.get(field, [])
            if not validator.validate_field(field, value):
                activity_errors.append(field)
                field_errors[field] += 1
        
        if activity_errors:
            total_errors += 1
            print(f"‚ùå Activity {i+1}: Errors in {activity_errors}")
    
    print(f"\nüìä VALIDATION SUMMARY:")
    print(f"   Total activities: {len(activities)}")
    print(f"   Activities with errors: {total_errors}")
    print(f"   Error rate: {total_errors/len(activities)*100:.1f}%")
    
    print(f"\nüìã ERRORS BY FIELD:")
    for field, count in field_errors.items():
        if count > 0:
            print(f"   {field}: {count} errors")


def quick_stats(input_file: str):
    """Show quick statistics about the labeled data."""
    activities = read_json(input_file)
    
    print(f"üìä LABEL STATISTICS for {len(activities)} activities")
    print("="*50)
    
    # Count non-empty labels by field
    for field in ['llm_ref_group', 'llm_target_population', 'llm_ref_setting', 
                  'llm_geographic_focus', 'llm_nexus', 'llm_funding_org', 'llm_implementing_org']:
        non_empty = sum(1 for a in activities if a.get(field, []))
        percentage = non_empty / len(activities) * 100
        print(f"{field}: {non_empty}/{len(activities)} ({percentage:.1f}%)")
    
    # Show most common values
    print(f"\nüè∑Ô∏è  MOST COMMON VALUES:")
    
    # Refugee groups
    ref_groups = {}
    for activity in activities:
        for group in activity.get('llm_ref_group', []):
            ref_groups[group] = ref_groups.get(group, 0) + 1
    if ref_groups:
        print(f"Refugee groups: {dict(sorted(ref_groups.items(), key=lambda x: x[1], reverse=True))}")
    
    # Target populations
    target_pops = {}
    for activity in activities:
        for pop in activity.get('llm_target_population', []):
            target_pops[pop] = target_pops.get(pop, 0) + 1
    if target_pops:
        print(f"Target populations: {dict(sorted(target_pops.items(), key=lambda x: x[1], reverse=True))}")


# Command-line interface functions
def main():
    """Main CLI interface."""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python -m lib.util_labels review <input_file> [output_file]")
        print("  python -m lib.util_labels validate <input_file>")
        print("  python -m lib.util_labels stats <input_file>")
        return
    
    command = sys.argv[1]
    
    if command == "review":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        input_file = sys.argv[2]
        output_file = sys.argv[3] if len(sys.argv) > 3 else None
        
        validator = LabelValidator()
        validator.review_activities(input_file, output_file)
        
    elif command == "validate":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        validate_labels_file(sys.argv[2])
        
    elif command == "stats":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        quick_stats(sys.argv[2])
        
    else:
        print(f"‚ùå Unknown command: {command}")


if __name__ == "__main__":
    main()
