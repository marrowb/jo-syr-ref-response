"""
Utility functions for validating and editing LLM-generated labels for IATI activities.

This module provides interactive tools to review, validate, and correct
the labels generated by the DSPy classifier.
"""

import json
import os
from typing import Dict, List, Any
from lib.util_file import read_json, write_json


class LabelValidator:
    """Interactive validator for LLM-generated labels."""
    
    def __init__(self):
        self.valid_ref_groups = ["Syria", "Palestine", "Iraq", "Yemen", "Sudan", "Other", "mixed_or_unspecified_refugees"]
        self.valid_target_populations = ["refugees", "host_communities", "general_population"]
        self.valid_settings = ["camp", "urban", "rural"]
        self.valid_nexus = ["humanitarian", "development"]
        
        self.label_fields = [
            'llm_ref_group',
            'llm_target_population', 
            'llm_ref_setting',
            'llm_geographic_focus',
            'llm_nexus',
            'llm_funding_org',
            'llm_implementing_org'
        ]
    
    def validate_field(self, field_name: str, value: List) -> bool:
        """Validate a specific field against allowed values."""
        if field_name == 'llm_ref_group':
            return all(v in self.valid_ref_groups for v in value)
        elif field_name == 'llm_target_population':
            return all(v in self.valid_target_populations for v in value)
        elif field_name == 'llm_ref_setting':
            return all(v in self.valid_settings for v in value)
        elif field_name == 'llm_nexus':
            return all(v in self.valid_nexus for v in value)
        elif field_name in ['llm_geographic_focus', 'llm_funding_org', 'llm_implementing_org']:
            return isinstance(value, list)  # Just check it's a list
        return True
    
    def display_activity(self, activity: Dict, index: int, total: int):
        """Display activity information in a readable format."""
        print("\n" + "="*80)
        print(f"ACTIVITY {index + 1} of {total}")
        print("="*80)
        
        print(f"\nüìã TITLE:")
        print(f"   {activity.get('title_narrative', 'N/A')}")
        
        print(f"\nüìù DESCRIPTION:")
        desc = activity.get('description_narrative', 'N/A')
        if len(desc) > 300:
            print(f"   {desc[:300]}...")
        else:
            print(f"   {desc}")
        
        print(f"\nüè∑Ô∏è  SECTOR NARRATIVE:")
        print(f"   {activity.get('sector_narrative', 'N/A')}")
        
        print(f"\nü§ñ CURRENT LABELS:")
        for i, field in enumerate(self.label_fields, 1):
            value = activity.get(field, [])
            valid = "‚úÖ" if self.validate_field(field, value) else "‚ùå"
            print(f"   {i}. {field}: {value} {valid}")
    
    def edit_field(self, current_value: List, field_name: str) -> List:
        """Interactive editing of a field value."""
        print(f"\nEditing {field_name}")
        print(f"Current value: {current_value}")
        
        if field_name == 'llm_ref_group':
            print(f"Valid options: {self.valid_ref_groups}")
        elif field_name == 'llm_target_population':
            print(f"Valid options: {self.valid_target_populations}")
        elif field_name == 'llm_ref_setting':
            print(f"Valid options: {self.valid_settings}")
        elif field_name == 'llm_nexus':
            print(f"Valid options: {self.valid_nexus}")
        
        print("Enter new value as JSON list (e.g., [\"Syria\", \"Iraq\"]) or press Enter to keep current:")
        new_input = input("> ").strip()
        
        if not new_input:
            return current_value
        
        try:
            new_value = json.loads(new_input)
            if not isinstance(new_value, list):
                print("‚ùå Error: Value must be a list")
                return current_value
            
            if not self.validate_field(field_name, new_value):
                print("‚ùå Error: Invalid values for this field")
                return current_value
            
            print(f"‚úÖ Updated to: {new_value}")
            return new_value
            
        except json.JSONDecodeError:
            print("‚ùå Error: Invalid JSON format")
            return current_value
    
    def review_activities(self, input_file: str, output_file: str = None):
        """Main review loop for activities."""
        if not os.path.exists(input_file):
            print(f"‚ùå Error: File {input_file} not found")
            return
        
        activities = read_json(input_file)
        if not activities:
            print("‚ùå Error: No activities found in file")
            return
        
        if output_file is None:
            base_name = os.path.splitext(input_file)[0]
            output_file = f"{base_name}_corrected.json"
        
        print(f"üöÄ Starting review of {len(activities)} activities")
        print(f"üìÅ Will save corrected labels to: {output_file}")
        print("\nCommands:")
        print("  Enter = Next activity")
        print("  e = Edit current activity")
        print("  b = Go back to previous activity")
        print("  j <number> = Jump to activity number")
        print("  s = Save and continue")
        print("  q = Save and quit")
        
        current_index = 0
        
        while current_index < len(activities):
            activity = activities[current_index]
            self.display_activity(activity, current_index, len(activities))
            
            command = input(f"\n[{current_index + 1}/{len(activities)}] Command: ").strip().lower()
            
            if command == '' or command == 'n':
                # Next activity
                current_index += 1
                
            elif command == 'e':
                # Edit current activity
                self.edit_activity(activity)
                
            elif command == 'b':
                # Previous activity
                if current_index > 0:
                    current_index -= 1
                else:
                    print("‚ùå Already at first activity")
                    
            elif command.startswith('j '):
                # Jump to activity
                try:
                    jump_to = int(command.split()[1]) - 1
                    if 0 <= jump_to < len(activities):
                        current_index = jump_to
                    else:
                        print(f"‚ùå Invalid activity number. Range: 1-{len(activities)}")
                except (ValueError, IndexError):
                    print("‚ùå Invalid jump command. Use: j <number>")
                    
            elif command == 's':
                # Save and continue
                write_json(activities, output_file)
                print(f"‚úÖ Saved progress to {output_file}")
                current_index += 1
                
            elif command == 'q':
                # Save and quit
                write_json(activities, output_file)
                print(f"‚úÖ Saved final results to {output_file}")
                break
                
            else:
                print("‚ùå Unknown command")
        
        # Final save
        write_json(activities, output_file)
        print(f"\nüéâ Review complete! Corrected labels saved to {output_file}")
    
    def edit_activity(self, activity: Dict):
        """Edit all fields of an activity."""
        print("\nüîß EDITING MODE")
        print("Select field to edit (or 'done' to finish):")
        
        while True:
            for i, field in enumerate(self.label_fields, 1):
                value = activity.get(field, [])
                valid = "‚úÖ" if self.validate_field(field, value) else "‚ùå"
                print(f"   {i}. {field}: {value} {valid}")
            
            choice = input("\nEnter field number (1-7) or 'done': ").strip()
            
            if choice.lower() == 'done':
                break
                
            try:
                field_index = int(choice) - 1
                if 0 <= field_index < len(self.label_fields):
                    field_name = self.label_fields[field_index]
                    current_value = activity.get(field_name, [])
                    new_value = self.edit_field(current_value, field_name)
                    activity[field_name] = new_value
                else:
                    print("‚ùå Invalid field number")
            except ValueError:
                print("‚ùå Invalid input")


def validate_labels_file(input_file: str):
    """Quick validation of all labels in a file."""
    validator = LabelValidator()
    activities = read_json(input_file)
    
    print(f"üîç Validating {len(activities)} activities...")
    
    total_errors = 0
    field_errors = {field: 0 for field in validator.label_fields}
    
    for i, activity in enumerate(activities):
        activity_errors = []
        
        for field in validator.label_fields:
            value = activity.get(field, [])
            if not validator.validate_field(field, value):
                activity_errors.append(field)
                field_errors[field] += 1
        
        if activity_errors:
            total_errors += 1
            print(f"‚ùå Activity {i+1}: Errors in {activity_errors}")
    
    print(f"\nüìä VALIDATION SUMMARY:")
    print(f"   Total activities: {len(activities)}")
    print(f"   Activities with errors: {total_errors}")
    print(f"   Error rate: {total_errors/len(activities)*100:.1f}%")
    
    print(f"\nüìã ERRORS BY FIELD:")
    for field, count in field_errors.items():
        if count > 0:
            print(f"   {field}: {count} errors")


def quick_stats(input_file: str):
    """Show quick statistics about the labeled data."""
    activities = read_json(input_file)
    
    print(f"üìä LABEL STATISTICS for {len(activities)} activities")
    print("="*50)
    
    # Count non-empty labels by field
    for field in ['llm_ref_group', 'llm_target_population', 'llm_ref_setting', 
                  'llm_geographic_focus', 'llm_nexus', 'llm_funding_org', 'llm_implementing_org']:
        non_empty = sum(1 for a in activities if a.get(field, []))
        percentage = non_empty / len(activities) * 100
        print(f"{field}: {non_empty}/{len(activities)} ({percentage:.1f}%)")
    
    # Show most common values
    print(f"\nüè∑Ô∏è  MOST COMMON VALUES:")
    
    # Refugee groups
    ref_groups = {}
    for activity in activities:
        for group in activity.get('llm_ref_group', []):
            ref_groups[group] = ref_groups.get(group, 0) + 1
    if ref_groups:
        print(f"Refugee groups: {dict(sorted(ref_groups.items(), key=lambda x: x[1], reverse=True))}")
    
    # Target populations
    target_pops = {}
    for activity in activities:
        for pop in activity.get('llm_target_population', []):
            target_pops[pop] = target_pops.get(pop, 0) + 1
    if target_pops:
        print(f"Target populations: {dict(sorted(target_pops.items(), key=lambda x: x[1], reverse=True))}")


# Command-line interface functions
def main():
    """Main CLI interface."""
    import sys
    
    if len(sys.argv) < 2:
        print("Usage:")
        print("  python -m lib.util_labels review <input_file> [output_file]")
        print("  python -m lib.util_labels validate <input_file>")
        print("  python -m lib.util_labels stats <input_file>")
        return
    
    command = sys.argv[1]
    
    if command == "review":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        input_file = sys.argv[2]
        output_file = sys.argv[3] if len(sys.argv) > 3 else None
        
        validator = LabelValidator()
        validator.review_activities(input_file, output_file)
        
    elif command == "validate":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        validate_labels_file(sys.argv[2])
        
    elif command == "stats":
        if len(sys.argv) < 3:
            print("‚ùå Error: Please provide input file")
            return
        
        quick_stats(sys.argv[2])
        
    else:
        print(f"‚ùå Unknown command: {command}")


if __name__ == "__main__":
    main()
